# Брайан Керниган, Роб Пайк. Практика программирования

## Глава 1. Стиль программирования

Пользуйтесь длинными, содержательными именами для глобальных объектов и короткими — для локальных.

Объявление каждого глобального имени полезно сопровождать кратким комментарием:

```
int npending =0; // текущая длина входной очереди
```

Например, следующая запись несет избыточную, дублирующуюся информацию:

```
queue.queueCapacity
```

**Учитывайте возможные побочные эффекты.**

при множественном присваивании результат может оказаться неправильным:

```c
str[i++] = str[i++] = ' ';

n = 1;
printf("%d %d\n", n++, n++);
```

Даже если оператор содержит всего одно инкрементирование, он все равно может дать непредсказуемый результат.
Если, например, вначале переменная i была равна 3, то элемент массива может получить значение как 3, так и 4.

```c
array[i++] = i;
```

**Используйте устойчивые конструкции (идиомы) для поддержания единого стиля.**

Идеоматический перебор в C++ и Java:

```c
for (i = 0; i < n; i++)
    array[i] = 1.0;
```

А вот стандартный цикл для перебора списка в языке С:

```c
for (р = list; р != NULL; р = p->next)
    ...
```

**Используйте каскад else if для реализации многовариантного выбора.**

Длинный каскад вложенных операторов if часто свидетельствует о низком качестве кода, а то и об откровенных ошибках в нем:
Этот каскад операторов if требует держать в уме "стек" условий и проверок, чтобы в нужных местах доставать из этого стека информацию.

```c
if (argc == з)
    if ((fin = fopen(argv[l], "г")) != NULL)
        if ((fout = fopen(argv[2], "w")) != NULL) {
            while ((c = getc(fin)) != EOF)
                putc (c, fout) ;
            fclose(fin); fclose(fout);
        } else
            printf("Can't open output file %s\n", argv[2]);
    else
        printf("Can1t open input file %s\n", argv[l]);
else
    printf("Usage: cp inputfile outputfile\n");
```

Поскольку в каждом случае выполняется максимум одна операция, следует воспользоваться системой операторов `else if`.  

```c
if (argc 1= 3)
    printf("Usage: cp inputfile outputfile\n");
else if ((fin = fopen(argv[1], "r")) == NULL)
    printf("Can't open input file %s\n", argv[l]);
else if ((fout = fopen(argv[2], "w")) == NULL) {
    printf("Can't open output file %s\n", argv[2]);
    fclose(fin);
} else {
    while ((c = getc(fin)) != EOF)
        putc(c, fout);
    fclose(fin);
    fclose(fout);
}

```

**Избегайте макрофункций.**


Макрофункция — это простая текстовая подстановка. Параметры в ее объявлении заменяются фактическими аргументами, и полученный фрагмент вставляется в виде текста на место вызова макроса.

Представители старой школы программирования на С очень любят писать макросы вместо функций для быстрых и коротких вычислений, которые выполняются очень часто.Поводом для их написания служит повышение быстродействия — с помощью макроса можно избежать потерь времени на вызов функции. Но этот аргумент был не очень убедителен даже в первые годы существования С, когда компьютеры работали медленно, а функции вызывались долго; в настоящее время об этом вообще смешно говорить.   В языке C++ встраиваемые (inline) функции сделали функциональные макросы ненужными.

Одна из наиболее серьезных проблем с макрофункциями состоит в том, что если в ее определении несколько раз фигурирует один и тот же параметр, то он может вычисляться тоже несколько раз. Если макрофункция содержит операции с побочными эффектами, в результате получается трудноуловимая ошибка.

Неожиданные последствия побочного эффекта:

```c
#define isupper(c) ((c) >= 'A' && (c) <= 'Z')

// Контекст вызова
while (isupper(c = getchar()))

// На первый взгляд, вроде бы нет противоречий:
// Макрос принимает символ `c` который считывает getchar() и проверяет, является ли он заглавной буквой.

// Но, на самом деле макрос просто подставляется текстом, до компиляции!
while (((c = getchar()) >= 'A' && (c = getchar()) <= 'Z'))

// Теперь getchar() вызывается дважды!
// Теперь всякий раз, когда введенный символ по своему значению больше или равен 'А', он будет затираться следующим символом, сравниваемым уже с 'Z'.

// Перепишем корректно
while ((с = getchar()) != EOF && isupper(c))

```

Если все же вам необходимо определить макрофункцию, делайте это с осторожностью. Заключайте в скобки тело макрофункции и ее аргументы. 
 
```c
// Возьмем, например, следующй макрос:
#define macro_square(х) (х) * (х)

// и выражение
1 / macro_square(х)

// В этом случае макроподстановка даст следующее ошибочное выражение:
1 / (x) * (x)

// Чтобы исправить ошибку, макрос следует переписать таким образом:
#define square(х) ((х) * (х))

// тогда получим корректное выражение:
1 / ((x) * (x))
```

**Присваивайте константам символические имена.**

Вместо макросов `#define` и констант (когда используется какое-то значение без имени в ходе вычисления), используйте enum 

Это избавляет от логических ошибок при подстановки кода макроса в выражения на этапе компиляции.
И делает наглядным применение общих данных.
```c
#define  MINROW 1        /* верхний край */
#define  MINCOL 1        /* левый край */
// ...

// заменим на enum
enum {
     MINROW=1,           /* верхний край */
     MINCOL=1,           /* левый край */
     MAXROW=24,          /* нижний край (<=) */
     LABELROW=1,         /* местоположение меток */
     HEIGHT=MAXROW-4,    /* высота столбцов гистограммы */
};
```


**Используйте символьные константы, а не их числовые коды.**

Для анализа свойств символьных переменных следует пользоваться функциями из заголовочного файла <сtype.h> или их эквивалентами. 

Возьмем, например, следующую проверку:
```c
if (c >= 65 && c <= 90)

// Лучше записать это следующим образом:
if (c >= 'A' && c <= 'Z' )

// Но и эта конструкция может не дать желаемого эффекта, если буквы в наборе идут не подряд или же алфавит  включает и другие символы, лучше всего воспользоваться библиотечной функцией:
if (isupper(с))

```

Нечто подобное происходит с числом `0`, которое может фигурировать в программах в самых разных контекстах.
Конечно, компилятор всегда приведет его к нужному типу самостоятельно, однако при чтении программы полезно понимать, какую роль играет нуль в том или ином случае.
Например, в `С` для обозначения нулевого указателя следует пользоваться выражениями `(void *) 0` или `NULL`, а для представления нулевого байта в конце строки — выражением `'\0'`.

Лучше записать `0` таким образом, для:
```c
int x = 0; // int-литерал, в выражениях, где ожидается число, это просто «ноль»

str = NULL; // NULL или `(void *)0` — нулевой указатель
    // NULL — это макрос, определённый в <stddef.h> или <stdio.h>
    // #define NULL ((void *)0)

name[i] = '\0';// символьный литерал тип char, нулевой байт, конец строки (код 48), то есть терминатор строки.   
    // Используется, чтобы пометить конец строки в стиле C:
    char str[] = {'H', 'i', '\0'};
    printf("%s", str); // выведет "Hi" 
    
x = 0.0; // литерал с плавающей точкой, тип double, чтобы не было неявных преобразований типов
```

## Глава 2. Алгоритмы и структуры данных

> Полезно разобрать как устроены струтуры данных и как работают алгоритмы на примеры языка C 

Весь материал в репозиториях:
* [Implementation and understanding of data structures](https://github.com/Jekahome/Data-Structures)
* [Implementing algorithms and understanding complexity](https://github.com/Jekahome/Algorithms)

## Глава 3. Проектирование и реализация  

Мы хотим сгенерировать случайный текст на английском языке, который можно было бы прочитать. Если генерировать слова или буквы по счетчику случайных чисел, в результате получается бессмыслица.

`xptmxgn xusaja afqnzqxl lhidlwcd rjdjuvpydrlwnjy`

Также не слишком осмысленным получается текст, если составить его из слов, наугад выбранных из словаря:

`polydactyl equatorial splashily jowl verahdah circumscribe`

**Цепь Маркова**

Поставленная задача обработки данных изящно решается с помощью алгоритма,в котором используется цепь Маркова. Представим себе входные данные как цепочку перекрывающихся словосочетаний. Данный алгоритм делит каждую фразу на две части: префикс из нескольких слов и суффикс из одного слова, следующий за префиксом.

Вот некоторые пары слов из исходных данных и следующие за ними слова.

Префиксы из двух слов Слова-суффиксы

| Префиксы | Слова-суффиксы|
|----|----|
|Show your |flowcharts tables|
|your flowcharts |and will|
|flowcharts and |conceal|
|flowcharts will| be|
|your tables |and and|
|will be |mystified, obvious,|
|be mystified |Show|
|be obvious. |(end)|

Марковский алгоритм начинает свою работу по обработке этого текста с вывода слов `Show your`, а затем случайным образом выбирает либо `flowcharts`, либо `tables`. Если выбирается первый вариант, то префикс приобретает вид `your flowcharts` и следующее слово должно быть `and` или `will`. Если выбирается вариант `tables`, то следующим словом будет `and`. Так продолжается до тех пор, пока не будет сгенерировано достаточно текста или пока в качестве суффикса не встретится маркер (`end`).

> Текст, сгенерированный простой цепью Маркова, часто выглядит бессмысленным на длинных отрезках, потому что базовая модель:
> 
> * Смотрит только на предыдущее состояние: Цепь Маркова первого порядка (самая простая) помнит только одно предыдущее слово (или символ). Она не "понимает" грамматику, синтаксис или общую логику всего предложения или абзаца.
> 
> * Не имеет памяти о смысле: Она просто использует вероятности перехода (какое слово чаще всего следует за предыдущим), что хорошо для локальной связности, но катастрофично для создания глобального, осмысленного повествования.
> 
> Для создания действительно качественного и связного текста сегодня используются гораздо более сложные модели, такие как рекуррентные нейронные сети (RNN) и, в основном, трансформеры (на которых построены современные большие языковые модели, например, ChatGPT, Gemini и другие).

> Цепи Маркова нужны не только для генерации текста. Это математическая модель, которая описывает последовательность случайных событий, где вероятность каждого последующего события зависит только от текущего состояния, а не от всей предыдущей истории (это называется свойством Маркова).

## Глава 4. Интерфейсы

### Сокрытие информации

**Сокрытие информации**: какие данные должны быть видимы пользователю, а какие — скрыты от него? Интерфейс должен обеспечивать несложный доступ к компонентам и при этом скрывать детали реализации так, чтобы ее можно было дорабатывать незаметно для пользователя. Сокрытие информации. Библиотека не должна накладывать никаких ограничений на длину входной строки или количество полей в ней.

Скрывайте подробности реализации. Реализация, стоящая за интерфейсом, должна быть скрыта от остальных частей программы так, чтобы ее изменение не повлияло ни на что за ее пределами. Этот организационный принцип известен под многими именами: сокрытие информации, инкапсуляция, абстрагирование, модуляризация и т.д. Все это разные названия для одной и той же идеи. Интерфейс должен скрывать детали реализации, несущественные для клиента (пользователя). Невидимые подробности можно легко изменить — например, для того, чтобы расширить область действия интерфейса, сделать его более эффективным или вообще заменить всю реализацию полностью.

Если в заголовочном файле нет подробного объявления структуры, а только ее имя, то такой тип часто называют скрытым (opaque), потому что его свойства невидимы, а все операции выполняются через указатель на какой-то реальный объект.

Избегайте глобальных переменных. Везде, где это возможно, передавайте ссылки на все данные через аргументы. Мы решительно настроены против открытости или общедоступности данных в любой форме — слишком уж сложно поддерживать корректную последовательность обработки данных, если дать пользователю право изменять переменные по его усмотрению.

Не делайте ничего за спиной пользователя. Библиотечная функция не должна записывать секретных файлов или переменных, а также изменять глобальные данные. Кроме того, ей следует быть крайне осторожной с модификацией данных в вызывающем модуле. А вот функция `strtok` нарушает сразу несколько из этих требований. Неприятно удивляет тот факт, что она записывает нулевые байты в середину строки ее исходных данных. То, что функция использует нулевой байт для обозначения места окончания предыдущей операции, подразумевает хранение неких секретных данных между ее вызовами, а это потенциальный источник ошибок и препятствие к параллельной работе нескольких экземпляров функции.

Выполняйте одну и ту же операцию везде одинаковым способом. Очень важно соблюдать согласованность и единообразие. А вот в стандартной библиотеке ввода-вывода С трудно предсказать порядок аргументов при вызове функций. В некоторых аргумент типа `FILE*` стоит первым, в некоторых — последним; размер и количество элементов передаются в какой угодно последовательности.  

### Управление ресурсами

**Управление ресурсами**: кто должен отвечать за распределение памяти и других ограниченных ресурсов? Основные проблемы — это как размещать и удалять объекты из памяти и как распоряжаться совместно используемыми экземплярами данных. Управление ресурсами. Необходимо решить, кто будет отвечать за совместно используемые данные. Кто должен открывать и закрывать файл исходных данных? Тот, кто его открывает, должен и закрывать: парные задачи должны выполняться на одном и том же уровне или в одном модуле.

Самый очевидный из таких ресурсов — это память, относительно которой всегда возникает вопрос, кто должен ее распределять и освобождать. Но есть и другие важные ресурсы совместного пользования, такие как открытые файлы и общие переменные. 

**Освобождайте ресурс на том же уровне, на котором он запрашивался**. Один из подходов к управлению размещением и освобождением ресурса заключается в том, чтобы его уничтожением ведала та же библиотека, пакет или интерфейс, которые отвечают за распределение памяти для него. Другая формулировка этого подхода такова — интерфейс не должен изменять статус существования ресурса так, чтобы это было заметно снаружи.

В деле сборки мусора существует целый ряд подходов и приемов. В некоторых схемах подсчитывается количество обращений к каждому объекту из модулей — ведется его счетчик ссылок. Объект освобождается тогда, когда его счетчик ссылок становится равным нулю. Эту технику можно запрограммировать в С и C++ явным образом для управления объектами общего пользования. В других методах периодически отслеживается путь от пула размещенных в памяти объектов ко всем объектам, на которые имеются ссылки. Объекты, для которых этот путь прослежен, считаются используемыми, тогда как объекты, на которые не ссылаются никакие другие, полагаются неиспользуемыми и могут быть освобождены.

Во избежание проблем необходимо писать **реентерабельный код**, т.е. такой, который работает корректно независимо от количества одновременно вызванных модулей. В реентерабельном коде нет ни глобальных переменных, ни статических локальных переменных, и вообще любых переменных, которые могут модифицироваться в то время, пока ими пользуется другой поток. Ключ к хорошему многопоточному программированию лежит в таком разделении компонентов, при котором они взаимодействуют только через четко определенные интерфейсы. Библиотеки, которые неосторожно предоставляют переменные в общее пользование, наносят смертельный удар по этой модели. (В многопоточной программе функция `strtok` — это настоящее стихийное бедствие, как и все функции из библиотеки С, которые хранят данные во внутренних статических переменных.) Если уж так необходимо отдавать переменные в общее пользование, то их необходимо снабдить каким-то механизмом захвата и блокирования, чтобы гарантировать единовременное обращение со стороны только одного потока.


### Обработка ошибок

**Обработка ошибок**: как распознавать ошибки и выдавать сообщения о них?
Какие меры необходимо принять, если произошла та или иная ошибка? В принципе, библиотечные функции не должны просто завершаться аварийно, если случается ошибка; тип ошибки необходимо сообщить вызывающему модулю, чтобы тот принял надлежащие меры. Не следует также выдавать сообщения об ошибках или открывать диалоговые окна, поскольку программа может выполняться в среде, где это неуместно и будет мешать работе.

Предположим, что нам требуется не просто написать несколько функций для своего собственного употребления, а сформировать библиотеку для передачи другим пользователям. Что должна делать функция в такой библиотеке, если случается непоправимая ошибка? Функции, приведенные ранее в этой главе, выводили на экран сообщение об ошибке и завершали программу аварийно. Это вполне подходит для многих программ, особенно небольших утилит и автономных приложений. Но во многих случаях такой образ действий окажется неправильным, поскольку не даст другим модулям программы шанса исправить положение. Например, текстовый редактор должен попытаться не потерять информацию из редактируемого документа. В некоторых ситуациях библиотечная функция не должна даже выводить сообщение, потому что программа вполне может выполняться в среде, где такое сообщение исказило бы выходные данные или просто пропало без следа. Разумный вариант — это выводить диагностические сообщения в файл-протокол, который можно читать независимо от других данных.

> можно запрогораммировать пару альтернативных режимов поведения при возникновении ошибок и исключительных ситуаций, и предоставить выбор на уровень выше. Ясно что не это для библиотеки, а не для конечного пользователя программы. 

**Перехватывайте ошибки на низком уровне, обрабатывайте их на высоком.**
Общий принцип гласит, что ошибки следует перехватывать на как можно более низком системном уровне, а вот обрабатывать их — на высоком. В большинстве случаев решать, что делать в связи с ошибкой, должен вызывающий, а не вызываемый модуль. Библиотечные функции могут помочь в этом, завершая ошибочную операцию корректно и неаварийно. Рассуждая таким образом, в случае несуществующего поля данных лучше возвращать `NULL`, чем завершать программу аварийно.


Во многих библиотечных функциях есть способ отличить возвращаемый нормальный результат от ошибочного. Так, функция ввода `getchar` возвращает элемент типа `char` в случае успеха и некоторое несимвольное значение типа `EOF` в случае конца файла или другой ошибки. Этот механизм не срабатывает, если возможные корректные данные заполняют весь диапазон возвращаемых функцией значений.

Было бы желательно отличать друг от друга различные исключительные состояния наподобие конца файла и др., а не сваливать их все в одну кучу и огульно называть "ошибками". Если это трудно, можно ограничиться возвратом одного "исключительного" результата, но определить еще одну функцию, которая бы по требованию выдавала более подробную информацию о последней случившейся ошибке. Именно такой подход принят в системе Unix и стандартной библиотеке С, в которой многие системные вызовы и библиотечные функции возвращают `-1`, а также помещают специфический код ошибки в глобальную переменную errno. Функция `strerror` служит для возврата строкового сообщения, ассоциированного с кодом ошибки.

**Используйте исключительные ситуации для действительно исключительных случаев**. В некоторых языках для перехвата необычных ситуаций и принятия мер существует механизм исключительных ситуаций. Если случается ошибка, выполнение программы направляется по альтернативному пути. Исключительные ситуации не следует использовать для работы с ожидаемыми, нормальными значениями данных. Неудача при открытии файла — это не очень-то экстраординарное событие; генерирование исключительной ситуации для такого случая выглядит слишком сильной мерой. В программах на С с помощью пары функций `setjmp` и `longjmp` можно организовать низкоуровневую системную базу для построения механизма исключительных ситуаций.

А как насчет восстановления ресурсов в случае ошибки? Должна ли библиотека пытаться восстановить ресурсы, если случается ошибка? Обычно не должна, но она может оказать услугу другим модулям, постаравшись оставить после себя информацию в настолько корректном и безопасном состоянии, насколько это возможно.

