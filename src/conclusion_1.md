# Бугаенко Егор. Элегантные объекты. Java Edition 2018.pdf

[Егор Бугаенко. "Elegant Objects" (Элегантные объекты).](https://habr.com/ru/companies/piter/articles/418157/)

Эта книга представляет собой сборник практических рекомен­даций (двадцать три совета сгруппированы в четыре главы), которые, как мне кажется, могут изменить ситуацию и остановить деградацию ООП.

Основная идея в книге - писать сопровождаемый код.

Все существующие ООП-языки предлагают рассматриватьобъекты как структуры данных с прикрепленными процеду­рами, что в корне неверно. Появляются новые языки, но ониделают так же или даже хуже. Объектно-ориентированныхпрограммистов заставляют думать так, как процедурные про­граммисты думали 40 лет назад. То есть думать не как объекты,а как компьютеры.Мне кажется, что ООП было разработано для решения проблемпроцедурного программирования, особенно на языках вроде Сили COBOL. Процедурный стиль написания кода очень простдля понимания теми, кто знает, что процессор последовательнообрабатывает инструкции, манипулирующие данными в памя­ти. Фрагмент кода на С, также известный как функция, - этомножество операторов, которые должны выполняться в хро­нологическом порядке. Но при этом существует проблема с сопровождением.Автор кода более или менее понимает, как тот работает, покапишет его. Но если заглянуть в него позже, то будет довольнотрудно выяснить, что имел в виду его создатель. Иными словами,код написан для компьютеров, а не для людей. Лучший примертакого императивно-процедурного языка - ассемблер. Он ближе всего к процессору и очень далек от языка, на котором люди общаются в жизни. В ассемблере нет клиентов, файлов, прямо­ угольников и цен. Только регистры, байты, биты и указатели - то,что процессор понимает лучше всего.

К счастью, некоторое время назад ситуация переменилась и про­блема сопровождения стала более важна, чем скорость исполне­ния или расходование памяти. Появились бо­лее высокоуровневые парадигмы программирования, такие как: функциональная, логическая и объектно-ориентированная. Они перенесли фокус внимания с машин на людей. Они позволили нам говорить на своем языке. Они помогли сделать код более читаемым и, как следствие, более простым для поддержки. Так было задумано.

И пускай у нас есть классы и объекты - у нас все еще остались операторы, инструкции и их последовательное исполнение. Мы больше не работаем напрямую с указателями, памятью и регистрами процессора, но основной принцип остается неиз­менным - мы даем инструкции процессору и манипулируем данными в памяти.

Но проблема сейчас и с про­граммным обеспечением, написанным нajava/Ruby/Python, - его невозможно поддерживать, поскольку оно **никогда не было объектно-ориентированным.**

---

## 1

Класс должен быть назван на основе того, чем он является, а не того, что он делает. То, что я делаю, и то, кто я есть, - две разные вещи. CashFormatter необходимо переименовать в cash, или USDCash, или CashinUSD и т. п. Иными словами, объекты должны характеризоваться своими способностями. То, что я есть, выражается в том, что я могу, а не в моих параметрах вроде роста, веса или цвета кожи. Имя класса, которое заканчивается на -er, говорит нам о том, что это создание является не объектом, а лишь набором про­цедур, которые могут манипулировать некоторыми данными.
Это процедурный стиль мышления, унаследованный многими объектно-ориентированными разработчиками из С, COBOL, BASIC и других языков. И все-таки как правильно называть классы? Все просто: посмотрите, что инкапсулируют объекты этого класса, и придумайте для этого название.

---

## 2

Чем больше в вашем классе конструкторов, тем лучше, тем удобнее классы для меня - их пользователя. 
Я хочу иметь воз­можность создать экземпляр класса Cash многими способами. Чем больше конструкторов, тем большую гиб­кость применения ваших классов вы обеспечиваете мне, своему клиенту.

Перегрузка методов - фундамен­
тальная и очень ;важная часть ООП. Она существенно улучшает читаемость кода, семантически приближая его к языку задачи.

**Основная цель - сопровождаемость**. Этот принцип позволит вам снизить сложность кода и избежать дублирования.

В Rust есть несколько способов создать объект с разными типами аргументов для его создания. Вот основные подходы:

**1. Конструкторы с разными именами**

```rust
struct Person {
    name: String,
    age: u32,
}

impl Person {
    // Конструктор по умолчанию
    fn new(name: String, age: u32) -> Self {
        Self { name, age }
    }
    
    // Конструктор только с именем (возраст по умолчанию)
    fn with_name(name: String) -> Self {
        Self { name, age: 0 }
    }
    
    // Конструктор только с возрастом (имя по умолчанию)
    fn with_age(age: u32) -> Self {
        Self { name: "Unknown".to_string(), age }
    }
    
    // Конструктор из кортежа
    fn from_tuple((name, age): (String, u32)) -> Self {
        Self { name, age }
    }
}

// Использование
let person1 = Person::new("Alice".to_string(), 30);
let person2 = Person::with_name("Bob".to_string());
let person3 = Person::with_age(25);
let person4 = Person::from_tuple(("Charlie".to_string(), 35));
```

**2. Использование паттерна Builder**

```rust
#[derive(Debug)]
struct Car {
    make: String,
    model: String,
    year: u32,
    color: Option<String>,
    price: Option<f64>,
}

struct CarBuilder {
    make: String,
    model: String,
    year: u32,
    color: Option<String>,
    price: Option<f64>,
}

impl CarBuilder {
    fn new(make: String, model: String, year: u32) -> Self {
        Self {
            make,
            model,
            year,
            color: None,
            price: None,
        }
    }
    
    fn color(mut self, color: String) -> Self {
        self.color = Some(color);
        self
    }
    
    fn price(mut self, price: f64) -> Self {
        self.price = Some(price);
        self
    }
    
    fn build(self) -> Car {
        Car {
            make: self.make,
            model: self.model,
            year: self.year,
            color: self.color,
            price: self.price,
        }
    }
}

// Использование
let car = CarBuilder::new("Toyota".to_string(), "Camry".to_string(), 2023)
    .color("Red".to_string())
    .price(25000.0)
    .build();
```

**3. Использование типажа From/TryFrom**

```rust
struct Point {
    x: f64,
    y: f64,
}

impl From<(f64, f64)> for Point {
    fn from((x, y): (f64, f64)) -> Self {
        Self { x, y }
    }
}

impl From<[f64; 2]> for Point {
    fn from([x, y]: [f64; 2]) -> Self {
        Self { x, y }
    }
}

impl From<&str> for Point {
    fn from(s: &str) -> Self {
        let parts: Vec<&str> = s.split(',').collect();
        let x = parts[0].parse().unwrap_or(0.0);
        let y = parts[1].parse().unwrap_or(0.0);
        Self { x, y }
    }
}

// Использование
let point1 = Point::from((10.0, 20.0));
let point2 = Point::from([15.0, 25.0]);
let point3 = Point::from("5.0,12.5");
```

**4. Использование enum для разных вариантов**

```rust
enum PersonData {
    Full { name: String, age: u32 },
    NameOnly(String),
    AgeOnly(u32),
}

struct Person {
    name: String,
    age: u32,
}

impl From<PersonData> for Person {
    fn from(data: PersonData) -> Self {
        match data {
            PersonData::Full { name, age } => Self { name, age },
            PersonData::NameOnly(name) => Self { name, age: 0 },
            PersonData::AgeOnly(age) => Self { name: "Unknown".to_string(), age },
        }
    }
}

// Использование
let person1 = Person::from(PersonData::Full {
    name: "Alice".to_string(),
    age: 30,
});
let person2 = Person::from(PersonData::NameOnly("Bob".to_string()));
```

**5. Использование дженериков**

```rust
struct Container<T> {
    value: T,
}

impl<T> Container<T> {
    fn new(value: T) -> Self {
        Self { value }
    }
}

// Специализированные конструкторы для разных типов
impl Container<String> {
    fn from_str(s: &str) -> Self {
        Self { value: s.to_string() }
    }
}

impl Container<i32> {
    fn from_f64(value: f64) -> Self {
        Self { value: value as i32 }
    }
}

// Использование
let container1 = Container::new(42);
let container2 = Container::new("hello".to_string());
let container3 = Container::from_str("world");
let container4 = Container::from_f64(3.14);
```

**6. Комбинация подходов**

```rust
#[derive(Debug)]
struct Config {
    host: String,
    port: u16,
    timeout: u64,
    retries: u32,
}

impl Config {
    // Базовый конструктор
    fn new(host: String, port: u16) -> Self {
        Self {
            host,
            port,
            timeout: 30,
            retries: 3,
        }
    }
    
    // Builder методы для опциональных полей
    fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = timeout;
        self
    }
    
    fn retries(mut self, retries: u32) -> Self {
        self.retries = retries;
        self
    }
}

// Альтернативные конструкторы
impl Config {
    fn from_url(url: &str) -> Option<Self> {
        let parts: Vec<&str> = url.split(':').collect();
        if parts.len() == 2 {
            let host = parts[0].to_string();
            let port = parts[1].parse().ok()?;
            Some(Self::new(host, port))
        } else {
            None
        }
    }
}

// Использование
let config1 = Config::new("localhost".to_string(), 8080)
    .timeout(60)
    .retries(5);

let config2 = Config::from_url("example.com:443").unwrap();
```

Выбор подхода зависит от конкретной ситуации:
- **Простые случаи** - используйте именованные конструкторы
- **Много опциональных параметров** - используйте Builder паттерн
- **Преобразование из разных типов** - используйте From/TryFrom
- **Разные варианты данных** - используйте enum
- **Обобщенные типы** - используйте дженерики

## 3

В конструкторах не должно быть кода.

Подход направлен на создание стабильных, предсказуемых объектов. Конструктор становится простой операцией композиции, а вся сложная логика выносится в фабрики, билдеры или "умные" типы данных.

Объекты как неизменяемые сущности, которые либо валидны, либо не существуют вообще. 
Для агрументов используется NewType

Подход направлен против бизнес-логики в конструкторах доменных объектов, но допускаем код в конструкторах примитивных типов NewType.


Если в конструкторе есть код, то он может нарушать принцип единой ответственности: добавление валидаций, нормализаций, логирования. Сложно тестировать, когда логика в конструкторе.

Суть не в полном отсутствии кода, а в:
* Разделении ответственности - примитивы валидируют данные, доменные объекты реализуют бизнес-логику
* Предсказуемости - конструктор доменного объекта всегда работает
* Тестируемости - бизнес-логика вынесена в тестируемые компоненты


Разделение создания и бизнес-логики:
```rust
// Объект создания
struct UserCreator;

impl UserCreator {
    fn create(&self, name: &str, email: &str) -> Result<User, String> {
        // Вся сложная логика здесь
        self.validate_name(name)?;
        self.validate_email(email)?;
        let normalized_name = self.normalize_name(name);
        let normalized_email = self.normalize_email(email);
        
        Ok(User::new(
            UserName(normalized_name),
            Email(normalized_email)
        ))
    }
    
    fn validate_name(&self, name: &str) -> Result<(), String> {
        // логика валидации
        Ok(())
    }
    
    // ... другие методы
}
```


Тестируемость:
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_user_creation() {
        let name = UserName::new("test").unwrap();
        let email = Email::new("test@test.com").unwrap();
        let user = User::new(name, email);
        // Легко тестировать без побочных эффектов
    }
}
```

**Если следовать принципу абсолютно строго**, все конструкторы, даже NewType, не имеют код, а только присвоение и валидация просиходит в методах отдельных фабрик валидаторов.


## 4

Класс должен иметь/инкапсулировать максимум четыре обьекта. Это империческое наблюдение, как правило излишние обьекты говорят о недоработанности структуры обьектов.

## 5

Класс не инкапсулирующий ничего т.е. статический, это значит у него нет состояния и идентичности, только поведение.

Инкапсулированное состояние - это уникалтный идентификатор объекта.

Инстанцирование должно быть отделено от исполнения, что означает следующее: оператор new разрешен лишь в конструкторах.

Мы определен­но можем создать объект, который ничего не инкапсулирует, и этому есть масса примеров. Но это неверно и с философской, и с практической точки зрения.


Суть инкапсуляции - в делегировании ответственности объекту. Таким образом объ­ект получает право управлять своими (и не только) данными удобным для себя способом.


## 6
Всегда используйте интерфейсы

Объект живет в тесном социальном окружении. (Дергать каждый обьект за его уникальные "руки", не так эффективно, как через общий канал связи - контракт, интерфейс)
Под этим я понимаю то, что объекты взаимосвязаны, поскольку они нуждаются друг в друге. В самом начале, когда мы точно знаем, что каждый объект должен делать и какие услуги предоставлять другим объектам, все просто. Но когда приложение начинает разрастаться и количество объектов превышает несколько десятков, тесная связь между ними становится серьезную и проблемой. И эта проблема влияет на сопровождаемость.

Чтобы повысить сопровождаемость приложения в целом,_мы должны приложить максимум усилий к **расцеплению (decoupling)** объекгов. 
Технически это означает возможность модифициропать объект, не модифицируя связанные с ним объекты. Лучший иструмент для этого - интерфейсы.

Удосто­верьтесь, что все публичные методы класса реализуют какой-то интерфейс. Грамотно спроектированный класс не должен содер­ жать публичных методов, которые не реализуют хотя бы один интерфейс. Даже если в коде эти методы используются один раз но не забывайте про тестирование. Если вы пишете грамотные юнит-тесты, то для создания **фиктивных** объектов интерфейсы понадобятся там тоже.


## 8

Публичные константы в ООП - чистейшее зло, они не должны использоваться никогда. Всегда заменяйте их микроклассами. Неважно, на­сколько малы они будут. Не решайте проблему дублирования кода публичными константами - применяйте классы. Кстати, то же самое касается типов enum в Java, а в Rust enum это обьект с поведение так что это не примитивная константа. Перечисления ничем не отличаются от публичных констант, и их также не­обходимо избегать.

Тут про то что классы становятся зависимыми от публичных констант которые сами по себе не знают за что отвечают т.е. у них нет поведения.

Объекты не должны ничего использовать совместно - они должны быть самодостаточными и очень закрытыми. Механизм совмесгного использования противоречит идее инкапсуляции и объектно-ориентированному образу мышления в целом.

Почему классы использующие константы имею сцепление - если мы поменяем значение константы, то поведение использующих коснтанту классов изменится непредсказуемым образом. 
Почему непредсказуемым? Посколь­ку, когда мы меняем значение константы, мы понятия не имеим, как оно используется.


Публичные константы в ООП это ПЛОХО, потому что:
* Неявная зависимость от глобального состояния
* Сложно тестировать (как подменить константу в тесте?)
* Нарушает инкапсуляцию

Альтернативы:
* Замена констант на объекты
* Конфигурация как зависимость

```rust
pub struct ApplicationConfig {
    user_limit: UserLimit,
    timeout: Timeout,
    api_url: ApiUrl,
}

impl ApplicationConfig {
    pub fn production() -> Self {
        Self {
            user_limit: UserLimit::new(100),
            timeout: Timeout::seconds(30),
            api_url: ApiUrl::new("https://api.example.com"),
        }
    }
    
    pub fn development() -> Self {
        Self {
            user_limit: UserLimit::new(10),
            timeout: Timeout::seconds(60),
            api_url: ApiUrl::new("https://dev-api.example.com"),
        }
    }
}

pub struct UserService {
    config: ApplicationConfig,
}

impl UserService {
    pub fn new(config: ApplicationConfig) -> Self {
        Self { config }
    }
    
    fn create_user(&self, user: User) -> Result<(), Error> {
        if self.user_count() >= self.config.user_limit.value() {
            return Err(Error::LimitExceeded);
        }
        // ...
    }
}
```

## 9

Изменяемые объекты - злоупотребление объектно-ориенти­ ронанной парадигмой.

> Бугаенко говорит, что изменяемые объекты не имеют права на существование. Их использование должно быть строго запрещено. Их просто не должно быть в ООП, как это сделано, например, в Haskell. Все классы должны инстанцировать неизменяемые объекты, которые никогда не меняют своего состояния вне зависимости от области применения, будь то игры, пользовательский интерфейс, мобильные или веб-приложения или даже алгоритмы.

"делайте классы неизменяемыми" это перегибает палку с неизменяемостью, так как:
* ❌ Непрактичен для high-performance кода
* ❌ Не работает с системным программированием
* ❌ Создает ненужные аллокации
* ❌ Усложняет код без реальной пользы


"делайте классы неизменяемыми" в Rust избыточен, потому что:
* Rust уже делает всё неизменяемым по умолчанию
* Система владения предотвращает случайные мутации
* Компилятор заставляет явно указывать mut
* Есть выбор между производительностью и безопасностью

## 10
Пишите тесты, а не документацию

Чтобы сделать свой код лучше читаемым, представьте, что я начинающий программист, слабо понимающий предметную область, язык программирования, шаблоны проектирования и алгоритмы. Представьте, что я намного глупее вас. Так вы демонстрируете свое уважение ко ·мне. Не хвастайтесь своими способностями - пишите простой легко читаемый код. Плохие программисты пишут сложный код. Хорошие программисты пишут простой код.

Мой вам совет: не документируйте код - делайте его чище.
Под этим я, в частности, понимаю написание юнит-тестов. Юнит-тест должен рассматриваться как часть класса наравне с методами, свойствами, именем и перечнем реализу­ емых интерфейсов. Один юнит-тест стоит страницы документации. Юнит-тест показывает мне, как использовать класс, в то время как документация рассказывает историю, которую намного труднее понять и интерпретировать. Не говорите, а показывайте.

## 11
Используйте fаkе-объекты вместо mосk-объектов


Почему Бугаенко за fakes:
* Fakes тестируют поведение, а mocks - implementation details
* Mocks делают тесты хрупкими - при изменении внутренней реализации тесты ломаются. Он привязывает тесты к внутренним деталям реализации
класса. Ставя тесты в зависимость от взаимодействия классов, мы де­лаем рефакторинг болезненным, а иногда и невозможным.
* Fakes ближе к реальности - тестируют то, что действительно важно для бизнеса


Практика в Rust, обычно используют оба подхода, но для разных целей:
* Fakes - для репозиториев, внешних сервисов, сложных зависимостей
* Mocks - для проверки специфических взаимодействий между компонентами


Fake - это рабочая, но упрощенная реализация, обычно для изоляции от внешних зависимостей:
```rust
// Настоящая база данных
struct Database { /* сложная логика */ }

// Fake-версия для тестов
struct FakeDatabase {
    data: HashMap<String, String>,
}

impl FakeDatabase {
    fn new() -> Self {
        Self { data: HashMap::new() }
    }
    
    // Такие же методы как у настоящей БД, но работают в памяти
    fn save(&mut self, key: &str, value: &str) {
        self.data.insert(key.to_string(), value.to_string());
    }
    
    fn load(&self, key: &str) -> Option<&str> {
        self.data.get(key).map(|s| s.as_str())
    }
}
```

Mock - это "шпион", который записывает вызовы и проверяет взаимодействия:
```rust
use mockall::automock;

#[automock]
trait EmailService {
    fn send_email(&self, to: &str, subject: &str) -> Result<(), String>;
}

// В тестах
let mut mock_email = MockEmailService::new();
mock_email.expect_send_email()
    .times(1)
    .returning(|_, _| Ok(()));

// Тестируем, что send_email был вызван ровно 1 раз
```


## 12
Делайте интерфейсы краткими, используйте smart-клaccы

#### Почему это работает в Rust

1. **Система типов** позволяет создавать "умные" типы с гарантиями на уровне компиляции
2. **Traits** естественно поддерживают разделение интерфейсов
3. **Newtype pattern** идеально реализует smart-классы

#### Суть подхода

- **Интерфейсы должны делать одну вещь** (Single Responsibility)
- **Типы должны гарантировать валидность** на уровне компиляции
- **Меньше методов = проще тестирование и использование**


Этот раздел очень хорошо ложится на философию Rust! 

#### Smart-классы вместо примитивов

**Вместо примитивных типов** в интерфейсах:

```rust
// ПЛОХО: примитивы в интерфейсе
fn create_user(name: String, age: i32, email: String) -> Result<User, String> {
    if age < 0 || age > 150 { return Err("Invalid age".to_string()); }
    if !email.contains('@') { return Err("Invalid email".to_string()); }
    // ...
}

// ХОРОШО: smart-типы
fn create_user(name: UserName, age: UserAge, email: Email) -> User {
    // Валидация уже выполнена в конструкторах типов
    User { name, age, email }
}
```

#### Краткие интерфейсы

**Вместо монолитных интерфейсов:**

```rust
// ПЛОХО: один интерфейс на все случаи
trait MonsterDatabase {
    fn save_user(&self, user: User) -> Result<(), Error>;
    fn find_user(&self, id: UserId) -> Option<User>;
    fn update_user(&self, user: User) -> Result<(), Error>;
    fn delete_user(&self, id: UserId) -> Result<(), Error>;
    fn find_users_by_age(&self, age: u32) -> Vec<User>;
    // ... еще 20 методов
}

// ХОРОШО: несколько специализированных интерфейсов
trait UserReader {
    fn find_user(&self, id: UserId) -> Option<User>;
    fn find_users_by_age(&self, age: u32) -> Vec<User>;
}

trait UserWriter {
    fn save_user(&self, user: User) -> Result<(), Error>;
    fn update_user(&self, user: User) -> Result<(), Error>;
    fn delete_user(&self, id: UserId) -> Result<(), Error>;
}
```

## 14
Короче говоря, данная глава посвящена
аргументам против крупных объектов, статических объектов,
NULL-ccылoк, геттеров, сеттеров и оператора new.

Не используйте статические методы

Бугаенко сожалеет обо всем том времени, которое потратил на написание процедурного, а не объектно-ориенти­рованного программного обеспечения. Я был слеп, но теперь прозрел. Статические методы - настолько же большая, если не еще большая проблема в ООП, чем наличие константы NULL. Статические методы ухудшают сопровождаемость про­ граммного обеспечения.

При компьютерном образе мышления (процедурное) мы находимся у руля и контролируем поток исполнения инструкций, компьютер работает на нас, а мы указываем ему, что делать, давая ему явные инструкции. При объектно­-ориентированном образе мышления мы просто определяем, кто есть кто, и пусть они взаимодействуют, когда это им пона­добится.

Меня не особо беспокоит, что находится внутри объекта класса Мах и как именно он реализует интерфейс Number. Я не даю процессору инструкции относитель­ но этого вычисления. Я просто инстанцирую объект.

Напротив, статические методы в ООП - то же самое, что под­программы в С или ассемблере. Они не имеют отношения к ООП и заставляют нас писать процедурный код в объектно-ориенти­ рованном синтаксисе.



















