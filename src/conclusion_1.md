# Бугаенко Егор. Элегантные объекты. Java Edition 2018.pdf

[Егор Бугаенко. "Elegant Objects" (Элегантные объекты).](https://habr.com/ru/companies/piter/articles/418157/)

Эта книга представляет собой сборник практических рекомен­даций (двадцать три совета сгруппированы в четыре главы), которые, как мне кажется, могут изменить ситуацию и остановить деградацию ООП.

Все существующие ООП-языки предлагают рассматриватьобъекты как структуры данных с прикрепленными процеду­рами, что в корне неверно. Появляются новые языки, но ониделают так же или даже хуже. Объектно-ориентированныхпрограммистов заставляют думать так, как процедурные про­граммисты думали 40 лет назад. То есть думать не как объекты,а как компьютеры.Мне кажется, что ООП было разработано для решения проблемпроцедурного программирования, особенно на языках вроде Сили COBOL. Процедурный стиль написания кода очень простдля понимания теми, кто знает, что процессор последовательнообрабатывает инструкции, манипулирующие данными в памя­ти. Фрагмент кода на С, также известный как функция, - этомножество операторов, которые должны выполняться в хро­нологическом порядке. Но при этом существует проблема с сопровождением.Автор кода более или менее понимает, как тот работает, покапишет его. Но если заглянуть в него позже, то будет довольнотрудно выяснить, что имел в виду его создатель. Иными словами,код написан для компьютеров, а не для людей. Лучший примертакого императивно-процедурного языка - ассемблер. Он ближе всего к процессору и очень далек от языка, на котором люди общаются в жизни. В ассемблере нет клиентов, файлов, прямо­ угольников и цен. Только регистры, байты, биты и указатели - то,что процессор понимает лучше всего.

К счастью, некоторое время назад ситуация переменилась и про­
блема сопровождения стала более важна, чем скорость исполне­
ния или расходование памяти. Появились бо­
лее высокоуровневые парадигмы программирования, такие как: 
функциональная, логическая и объектно-ориентированная. 
Они перенесли фокус внимания с машин на людей. Они позволили
нам говорить на своем языке. Они помогли сделать код более читаемым и, как
следствие, более простым для поддержки. Так было задумано.

И пускай у нас есть классы и объекты - у нас все еще остались
операторы, инструкции и их последовательное исполнение.
Мы больше не работаем напрямую с указателями, памятью
и регистрами процессора, но основной принцип остается неиз­
менным - мы даем инструкции процессору и манипулируем
данными в памяти.

Но проблема сейчас и с про­граммным обеспечением, написанным нajava/Ruby/Python, - его невозможно поддерживать, поскольку оно **никогда не было объектно-ориентированным.**

---

## 1

Класс должен быть назван на основе того, чем он является, а не того, что он делает. То, что я делаю, и то, кто я есть, - две разные вещи. CashFormatter необходимо
переименовать в cash, или USDCash, или CashinUSD и т. п. Иными словами, объекты должны характеризоваться своими
способностями. То, что я есть, выражается в том, что я могу, а не
в моих параметрах вроде роста, веса или цвета кожи. Имя класса, которое заканчивается на -er, говорит нам о том,
что это создание является не объектом, а лишь набором про­
цедур, которые могут манипулировать некоторыми данными.
Это процедурный стиль мышления, унаследованный многими
объектно-ориентированными разработчиками из С, COBOL,
BASIC и других языков. И все-таки как правильно называть классы? Все просто: посмотрите, что инкапсулируют объекты этого
класса, и придумайте для этого название.

---

## 2

Чем больше в вашем классе конструкторов, тем лучше, тем
удобнее классы для меня - их пользователя. Я хочу иметь воз­
можность создать экземпляр класса Cash многими способами. Чем больше конструкторов, тем большую гиб­
кость применения ваших классов вы обеспечиваете мне, своему
клиенту.

Перегрузка методов - фундамен­
тальная и очень ;важная часть ООП. Она существенно улучшает
читаемость кода, семантически приближая его к языку задачи.

**Основная цель - сопровождаемость**. Этот принцип позволит вам снизить сложность кода и избежать дублирования.

В Rust есть несколько способов создать объект с разными типами аргументов для его создания. Вот основные подходы:

**1. Конструкторы с разными именами**

```rust
struct Person {
    name: String,
    age: u32,
}

impl Person {
    // Конструктор по умолчанию
    fn new(name: String, age: u32) -> Self {
        Self { name, age }
    }
    
    // Конструктор только с именем (возраст по умолчанию)
    fn with_name(name: String) -> Self {
        Self { name, age: 0 }
    }
    
    // Конструктор только с возрастом (имя по умолчанию)
    fn with_age(age: u32) -> Self {
        Self { name: "Unknown".to_string(), age }
    }
    
    // Конструктор из кортежа
    fn from_tuple((name, age): (String, u32)) -> Self {
        Self { name, age }
    }
}

// Использование
let person1 = Person::new("Alice".to_string(), 30);
let person2 = Person::with_name("Bob".to_string());
let person3 = Person::with_age(25);
let person4 = Person::from_tuple(("Charlie".to_string(), 35));
```

**2. Использование паттерна Builder**

```rust
#[derive(Debug)]
struct Car {
    make: String,
    model: String,
    year: u32,
    color: Option<String>,
    price: Option<f64>,
}

struct CarBuilder {
    make: String,
    model: String,
    year: u32,
    color: Option<String>,
    price: Option<f64>,
}

impl CarBuilder {
    fn new(make: String, model: String, year: u32) -> Self {
        Self {
            make,
            model,
            year,
            color: None,
            price: None,
        }
    }
    
    fn color(mut self, color: String) -> Self {
        self.color = Some(color);
        self
    }
    
    fn price(mut self, price: f64) -> Self {
        self.price = Some(price);
        self
    }
    
    fn build(self) -> Car {
        Car {
            make: self.make,
            model: self.model,
            year: self.year,
            color: self.color,
            price: self.price,
        }
    }
}

// Использование
let car = CarBuilder::new("Toyota".to_string(), "Camry".to_string(), 2023)
    .color("Red".to_string())
    .price(25000.0)
    .build();
```

**3. Использование типажа From/TryFrom**

```rust
struct Point {
    x: f64,
    y: f64,
}

impl From<(f64, f64)> for Point {
    fn from((x, y): (f64, f64)) -> Self {
        Self { x, y }
    }
}

impl From<[f64; 2]> for Point {
    fn from([x, y]: [f64; 2]) -> Self {
        Self { x, y }
    }
}

impl From<&str> for Point {
    fn from(s: &str) -> Self {
        let parts: Vec<&str> = s.split(',').collect();
        let x = parts[0].parse().unwrap_or(0.0);
        let y = parts[1].parse().unwrap_or(0.0);
        Self { x, y }
    }
}

// Использование
let point1 = Point::from((10.0, 20.0));
let point2 = Point::from([15.0, 25.0]);
let point3 = Point::from("5.0,12.5");
```

**4. Использование enum для разных вариантов**

```rust
enum PersonData {
    Full { name: String, age: u32 },
    NameOnly(String),
    AgeOnly(u32),
}

struct Person {
    name: String,
    age: u32,
}

impl From<PersonData> for Person {
    fn from(data: PersonData) -> Self {
        match data {
            PersonData::Full { name, age } => Self { name, age },
            PersonData::NameOnly(name) => Self { name, age: 0 },
            PersonData::AgeOnly(age) => Self { name: "Unknown".to_string(), age },
        }
    }
}

// Использование
let person1 = Person::from(PersonData::Full {
    name: "Alice".to_string(),
    age: 30,
});
let person2 = Person::from(PersonData::NameOnly("Bob".to_string()));
```

**5. Использование дженериков**

```rust
struct Container<T> {
    value: T,
}

impl<T> Container<T> {
    fn new(value: T) -> Self {
        Self { value }
    }
}

// Специализированные конструкторы для разных типов
impl Container<String> {
    fn from_str(s: &str) -> Self {
        Self { value: s.to_string() }
    }
}

impl Container<i32> {
    fn from_f64(value: f64) -> Self {
        Self { value: value as i32 }
    }
}

// Использование
let container1 = Container::new(42);
let container2 = Container::new("hello".to_string());
let container3 = Container::from_str("world");
let container4 = Container::from_f64(3.14);
```

**6. Комбинация подходов**

```rust
#[derive(Debug)]
struct Config {
    host: String,
    port: u16,
    timeout: u64,
    retries: u32,
}

impl Config {
    // Базовый конструктор
    fn new(host: String, port: u16) -> Self {
        Self {
            host,
            port,
            timeout: 30,
            retries: 3,
        }
    }
    
    // Builder методы для опциональных полей
    fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = timeout;
        self
    }
    
    fn retries(mut self, retries: u32) -> Self {
        self.retries = retries;
        self
    }
}

// Альтернативные конструкторы
impl Config {
    fn from_url(url: &str) -> Option<Self> {
        let parts: Vec<&str> = url.split(':').collect();
        if parts.len() == 2 {
            let host = parts[0].to_string();
            let port = parts[1].parse().ok()?;
            Some(Self::new(host, port))
        } else {
            None
        }
    }
}

// Использование
let config1 = Config::new("localhost".to_string(), 8080)
    .timeout(60)
    .retries(5);

let config2 = Config::from_url("example.com:443").unwrap();
```

Выбор подхода зависит от конкретной ситуации:
- **Простые случаи** - используйте именованные конструкторы
- **Много опциональных параметров** - используйте Builder паттерн
- **Преобразование из разных типов** - используйте From/TryFrom
- **Разные варианты данных** - используйте enum
- **Обобщенные типы** - используйте дженерики

## 3

В конструкторах не должно быть кода.

Подход направлен на создание стабильных, предсказуемых объектов. Конструктор становится простой операцией композиции, а вся сложная логика выносится в фабрики, билдеры или "умные" типы данных.

Объекты как неизменяемые сущности, которые либо валидны, либо не существуют вообще. 
Для агрументов используется NewType

Подход направлен против бизнес-логики в конструкторах доменных объектов, но допускаем код в конструкторах примитивных типов NewType.


Если в конструкторе есть код, то он может нарушать принцип единой ответственности: добавление валидаций, нормализаций, логирования. Сложно тестировать, когда логика в конструкторе.

Суть не в полном отсутствии кода, а в:
* Разделении ответственности - примитивы валидируют данные, доменные объекты реализуют бизнес-логику
* Предсказуемости - конструктор доменного объекта всегда работает
* Тестируемости - бизнес-логика вынесена в тестируемые компоненты


Разделение создания и бизнес-логики:
```rust
// Объект создания
struct UserCreator;

impl UserCreator {
    fn create(&self, name: &str, email: &str) -> Result<User, String> {
        // Вся сложная логика здесь
        self.validate_name(name)?;
        self.validate_email(email)?;
        let normalized_name = self.normalize_name(name);
        let normalized_email = self.normalize_email(email);
        
        Ok(User::new(
            UserName(normalized_name),
            Email(normalized_email)
        ))
    }
    
    fn validate_name(&self, name: &str) -> Result<(), String> {
        // логика валидации
        Ok(())
    }
    
    // ... другие методы
}
```


Тестируемость:
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_user_creation() {
        let name = UserName::new("test").unwrap();
        let email = Email::new("test@test.com").unwrap();
        let user = User::new(name, email);
        // Легко тестировать без побочных эффектов
    }
}
```

**Если следовать принципу абсолютно строго**, все конструкторы, даже NewType, не имеют код, а только присвоение и валидация просиходит в методах отдельных фабрик валидаторов.


## 4

Класс должен иметь/инкапсулировать максимум четыре обьекта. Это империческое наблюдение, как правило излишние обьекты говорят о недоработанности структуры обьектов.

## 5

Класс не инкапсулирующий ничего т.е. статический, это значит у него нет состояния и идентичности, только поведение.

Инкапсулированное состояние - это уникалтный идентификатор объекта.

Инстанцирование должно быть отделено от исполнения, что означает следующее: оператор new разрешен лишь в конструкторах.

Мы определен­но можем создать объект, который ничего не инкапсулирует, и этому есть масса примеров. Но это неверно и с философской, и с практической точки зрения.


Суть инкапсуляции - в делегировании ответственности объекту. Таким образом объ­ект получает право управлять своими (и не только) данными удобным для себя способом.


## 6
Всегда используйте интерфейсы

Объект живет в тесном социальном окружении. (Дергать каждый обьект за его уникальные "руки", не так эффективно, как через общий канал связи - контракт, интерфейс)
Под этим я понимаю то, что объекты взаимосвязаны, поскольку они нуждаются друг в друге. В самом начале, когда мы точно знаем, что каждый объект должен делать и какие услуги предоставлять другим объектам, все просто. Но когда приложение начинает разрастаться и количество объектов превышает несколько десятков, тесная связь между ними становится серьезную и проблемой. И эта проблема влияет на сопровождаемость.









