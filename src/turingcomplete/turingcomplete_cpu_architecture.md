# CPU Architecture

* [Arithmetic Engine](#arithmetic-engine)
* [Registers](#registers)
* [Instruction Decoder](#instruction-decoder)
* [Calculations](#calculations)

## Arithmetic Engine

> [!TIP]
> Разблокирует фабрику компонентов, что позволит создавать собственные компоненты для уровней CPU Architecture.
 
Arithmetic Logic Unit (ALU) Арифметико-логическое устройство

Коротко что это значит:
* Arithmetic — сложение, вычитание, инкремент, декремент
* Logic — AND, OR, XOR, NOT, сравнения
* Unit — отдельный функциональный блок процессора

> Задача: 
>
> Добавить еще два варианта в схему [Logic Engine](turingcomplete_arithmetic.html#logic-engine):
> * ADD для сложения двух восьмибитных чисел
> * SUB для вычитания двух восьмибитных чисел
> ```
> 0 OR
> 1 NAND
> 2 NOR
> 3 AND
> 4 ADD
> 5 SUB
> ```
> т.е. нам хватит первых трех младших битов
> ```
> OPCODE:
> 000 OR
> 001 NAND
> 010 NOR
> 011 AND
> 100 ADD
> 101 SUB
> ```

![Arithmetic Engine](/Computer-Science-Bookshelf/img/tc/Arithmetic_Engine.png)


Схема созданного вами компонента определяет его функционал, а планировка определяет форму. Имеено по этой причине, нельзя было двигать красные компоненты на схеме, так как они участвуют в форме нового компонента.

![New_Component_ALU](/Computer-Science-Bookshelf/img/tc/New_Component_ALU.png)
 

---

## Registers

Пришло время создать свой главный проект, реализующий компьютерную архитектуру OVERTURE. Это будет настоящая машина, полная по Тьюрингу, истинный компьютер во всех смыслах!

Этот уровень — реализация инструкции MOV между регистрами, где адреса источника и назначения закодированы в байте инструкции.

> Задача: Создайте схему распределения/получения данных соответствующую спецификации 
>
> На схеме вам дается:
> * 8-ми битный компонент для получения инструкции 
> * 5 ячеек памяти в виде 8-ми битных регистров
> * внешний вход 8-ми битных данных
> * внешний выход 8-ми битных данных
>
> На этом уровне вам нужно создать схему которая может копировать из источника в место назначения.
> 
> Байт инструкции на этом уровне определяет источник Source и место назначения Destination.
> 
> Инструкция — это 8 бит, но используются 6 из них:
>
> ```
> [ x  x | S2  S1  S0 | D2  D1  D0  ]
> [ x  x | Source     | Destination ]
> ```
>
> 

![REG](/Computer-Science-Bookshelf/img/tc/REG.png)

> В качестве источника и получателя может выступать один из 6 регистров, которые мы обозначим соответственно REG 0,... REG 5.
>
> Кроме того, эта карта имеет отдельный входной компонент, который может быть источником, и выходной компонент, который может быть пунктом назначения.

Назначение адреса для источника Source:
```
OPCODE Source:

S2 S1 S0
0  0  0  REG 0
0  0  1  REG 1
0  1  0  REG 2
0  1  1  REG 3
1  0  0  REG 4
1  0  1  REG 5
1  1  0  INPUT # использовать внешний вход
1  1  1  UNUSED
```

Назначение адреса для назначения Destination:
```
OPCODE Destination:

D2 D1 D0 
0  0  0  REG 0
0  0  1  REG 1
0  1  0  REG 2
0  1  1  REG 3
1  0  0  REG 4
1  0  1  REG 5
1  1  0  OUTPUT # использовать внешний выход
1  1  1  UNUSED
```

Например такие инструкции: 
* `00000110 => Source 000 (REG 0) и Destination 110 (OUTPUT)` что означает взять данные из `REG 0` и переслать их во внешний `OUTPUT`
* `00011001 => Source 011 (REG 3) и Destination 001 (REG 1)` что означает взять данные из `REG 3` и переслать их в `REG 1`
* `00110110 => Source 110 (INPUT) и Destination 110 (OUTPUT)` что означает взять данные из внешнего `INPUT` и переслать их во внешний `OUTPUT`


![Registers](/Computer-Science-Bookshelf/img/tc/Registers.png)

---

## Instruction Decoder

Декодер 2 на 4

Схема, которую вы построили на уровне Registers, может копировать значения между регистрами, в то время как "Арифметический Блок" (ALU) может выполнять различные операции над 2-мя входами. 

Но вам нужно делать и то и другое в одной и той же схеме. 

> Задача: Постройте "декодер", который будет определять в каком режиме наш компьютер находится, основываясь на 2-х битах которые вы до сих пор не использовали.

Что бы отличать 4 инструкции MODE, они будут кодировать первыми (старшими) двумя битами:

```
[ M1 M0 | S2 S1 S0 | D2  D1  D0  ]
[ MODE  | Source   | Destination ]

OPCODE MODE:
00xxxxxx непосредственные значения
01xxxxxx вычислить (ALU)
10xxxxxx копировать
11xxxxxx состояние
```

Определите текущий режим работы по входным данным, затем отправьте 1 на соответствующий выход.

![Instruction Decoder](/Computer-Science-Bookshelf/img/tc/Decoder_2_to_4.png)


Или используйте Byte Splitter для получения доступа к исходным битам, а затем 3-битный декодер для декодирования высоких бит на четыре выхода.

![Instruction Decoder](/Computer-Science-Bookshelf/img/tc/Turing_Complete_Instruction_Decoder_2_to_4.png)

---

## Calculations

Пришло время объединить "Арифметический Блок" (ALU) который вы сделали ранее [Arithmetic Engine](#arithmetic-engine) и схему регистров [Registers](#registers). 

Вычислительная схема была сохранена в заводе компонентов и теперь может быть добавлена как компонент. 

Если вы забыли какое соединение что делает, посмотрите на схему в заводе компонентов.

> Задача: Используйте декодер (Декодер 2 на 4) который вы построили ранее чтобы понять должны ли вы копировать между регистрами или делать вычисления (ALU). 
> 
> Вот 4 режима (напоминание):
> ```
> [ M1 M0 | S2 S1 S0 | D2  D1  D0  ]
> [ MODE  | Source   | Destination ]
>
> OPCODE MODE:
> 0 0 непосредственные значения (не нужен сейчас)
> 0 1 вычислить (ALU)
> 1 0 копировать 
> 1 1 состояние (не нужен сейчас)
> ```
> 
> На этом уровне вам нужно беспокоиться только о режимах копирования и вычисления (ALU). 
> 
> Когда вы находитесь в режиме вычислений (ALU), используйте `REG 1` и `REG 2` в качестве входов, а результат сохраните в `REG 3`.
> 
> Не забудьте что у 3-х битового декодера есть выключающий бит.

Для двух старших бит можно использовать декодер 2 на 4 который мы построили ранее на уровне [Instruction Decoder](#instruction-decoder) он тоже принимает 8 бит но реагирует только на первых два старших.  

Уже есть:
* блок регистров (REG0–REG5, INPUT, OUTPUT)
* ALU как готовый компонент
* декодеры

Теперь нужно:
* выбрать режим работы
* либо копировать данные
* либо выполнить вычисление через ALU


